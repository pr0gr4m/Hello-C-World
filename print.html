<!DOCTYPE HTML>
<html lang="kr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hello C World</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="C언어 기본서 오픈 집필">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">01. C언어 소개</li><li class="chapter-item expanded "><a href="01-introduce-c/history.html">C언어의 역사</a></li><li class="chapter-item expanded "><a href="01-introduce-c/feature.html">C언어의 특징</a></li><li class="chapter-item expanded "><a href="01-introduce-c/setting.html">실습 환경 구축</a></li><li class="chapter-item expanded affix "><li class="part-title">02. C언어 시작하기</li><li class="chapter-item expanded "><a href="02-start-c/helloworld.html">Hello World</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hello C World</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/pr0gr4m/Hello-C-World" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="c언어의-역사"><a class="header" href="#c언어의-역사">C언어의 역사</a></h1>
<p>해당 챕터에서는 C언어의 역사에 대해 다소 자세히 설명할 예정입니다. 혹시 독자분들은 역사 과목을 좋아하시나요? 필자는 개인적으로 학창 시절 역사 과목이 정말 지루하고 싫었습니다. 관심도 흥미도 없는 분야에 대해 억지로 외워야 하는 것이 성향에 안 맞았던 것 같습니다. 마찬가지로, C언어의 역사에 큰 관심이 없는 독자분들에게 해당 챕터는 다소 지루한 이야기일 수 있습니다. 심지어, 해당 내용을 모른다고 해서 C언어를 사용하는데는 별 문제가 되지 않습니다. 따라서 당장 본격적인 C언어 프로그래밍을 하고 싶으신 독자분들은 이번 챕터를 뛰어 넘으셔도 괜찮습니다. 잠깐, 그렇다면 굳이 몰라도 되는 역사 이야기를 왜 굳이 상세하게 하려고 할까요? C언어를 깊이 공부시다보면 '언어를 대체 왜 이렇게 만들었지?' 라는 의문이 들 때가 있습니다. 또, 독자분들이 보기에는 그다지 중요해보이지 않은 내용인데 이놈의 필자는 왜 이렇게 복잡하게 설명하고 있지 하는 의문이 드는 내용이 있을 것입니다. C언어의 역사를 알게 되면 그 의문들에 대해 어느정도 해답을 유추할 수 있게 되기에 다소 지루할 수 있는 내용이지만 조금 자세하게 이야기 해보려 합니다. (그리고 잘 알고 있으면, 어디 가서 아는 척 할 기회가 있을 겁니다.) </p>
<p>C언어의 역사는 미국의 벨 연구소에서 시작됩니다. 벨 연구소는 수많은 노벨상 수상자를 배출해낸 세계 최고의 과학 연구소 중 하나였습니다. 당시 벨 연구소에는 약 3천명의 고급 연구원과 2만명의 개발 그룹원이 있었는데, 이들의 연구 자금을 AT&amp;T라는 기업에서 투자해줬습니다. AT&amp;T는 미국 대부분의 지역에 전화 서비스를 제공한 세계 최대 통신 기업이었습니다. 따라서 벨 연구소는 자연스레 통신 시스템과 컴퓨터 과학에 대한 연구도 선구하게 되었습니다. 이 벨 연구소의 컴퓨팅 과학 연구 센터에는 (비록 합류 날짜는 제각각이지만) 더글러스 매클로이, 켄 톰슨, 데니스 리치와 같은 전설적인 프로그래머들이 근무했습니다.</p>
<p>1964년 MIT에서는 CTSS라는 운영체제를 개선하여 멀틱스(Multiplexed Information and Computing Service)라는 운영체제를 만들기 시작했습니다. 1966년부터 벨 연구소의 위 멤버들은 멀틱스 프로젝트에 참여했습니다. 하지만 프로젝트를 진행하다보니 벨 연구소는 멀틱스가 범용적으로 사용하기 좋은 운영체제가 되지 못할 것이라 생각하여 1969년 프로젝트에서 빠져나오게 됩니다. 프로젝트에서 빠져나온 켄 톰슨은 여전히 운영체제 개발을 하고 싶었고, 벨 연구소에서 당시 잘 사용하지 않고 있던 DEC사의 PDP-7 머신을 발견했습니다. 켄 톰슨은 PDP-7에서 동작할 운영체제를 개발하기 시작했고, 그의 아내가 아들을 데리고 3주간 시댁에 방문하러 갔을 때 시기는 무르익었습니다. 온전히 개발에 매진할 수 있게 된 켄 톰슨은 첫 주에 코드 작성을 위한 편집기를, 둘째 주에는 소스 코드(당시 어셈블리)를 기계어로 변환하기 위한 어셈블러를, 마지막 주에는 커널 오버레이를 개발했으며, 이 커널 오버레이를 운영체제라고 불렀습니다. 이렇게 1969년에 탄생한 운영체제는 멀틱스(MULTICS)의 이름을 오마쥬하여 유닉(UNICS)으로 지어졌으며, 이 이름이 어찌저찌 변형되어(UNICS의 발음이 내시라는 단어의 eunuch와 같아서 변형되었다는 이야기가 있습니다) 유닉스(UNIX)가 되었습니다.</p>
<p>켄 톰슨과 데니스 리치는 성공적으로 연구원들의 인기 몰이를 해낸 PDP-7 유닉스 시스템을 개선하기 위하여 PDP-11을 구하고, 유닉스를 새로운 시스템에 맞춰 변환했습니다. 그렇게 만들어진 PDP-11에서 동작하는 유닉스 버전이 유닉스 제 1판이 되었습니다. 그런데 켄 톰슨은 이렇게 유닉스를 개선하는 과정에서 어셈블리가 아닌 새로운 고수준 언어의 필요성을 느꼈습니다. 먼저 포트란이라는 언어로 작성하는 것을 시도하였으나 메모리 문제로 실패하고, BCPL이라는 언어를 직접 단순화하여 B라는 언어를 만들어 시도했습니다. 하지만, B언어는 인터프리팅 방식으로 동작하여 너무 느렸고, PDP-11 머신의 다양한 크기의 데이터 타입 기능을 이용할 수 없었습니다. (어셈블리, 데이터 타입, 인터프리팅과 같은 용어는 모른다면 건너 뛰셔도 괜찮습니다.) 기존 PDP-7 머신의 메모리는 워드 단위(PDP-7에서는 18비트)로 설계되었는데, PDP-11은 바이트(8비트)로 설계되어 단일 바이트, 2바이트 정수, 4바이트/8바이트 부동 소수점 수의 데이터 타입을 제공했습니다. 즉, B언어는 워드 기반 컴퓨터에 적합하고 이러한 바이트 기반 컴퓨터에는 적합하지 않은 언어였습니다.</p>
<p>1971년에 데니스 리치는 이 문제를 해결하기 위하여 B언어를 개선하기 시작했습니다. 위에서 이야기한 데이터 타입을 추가했고, 인터프리팅 방식이 아닌 컴파일 방식을 채택했습니다. 이 언어는 New B라는 의미의 NB가 되었고, 켄 톰슨은 NB를 이용하기 시작했습니다. NB에 필요에 따라 구조체(struct)와 같은 다양한 타입과 포인터 등이 추가 되어 결국 C언어가 되었습니다. 유닉스 버전 2에는 C언어 컴파일러가 포함되었고, 1973년 마침내 켄 톰슨과 데니스 리치는 C언어로 다시 작성된 유닉스 버전 4를 만들어 PDP-11에서 동작하는데 성공했습니다.</p>
<p>그렇게 탄생한 C언어는 1978년 브라이언 커닝핸과 데니스 리치가 집필한 The C Programming Language(이후 TCPL)와 함께 널리 퍼져나가기 시작했습니다. C언어는 유닉스 뿐만 아니라, IBM PC 플랫폼, 메인 프레임 컴퓨터, 마이크로 컴퓨터 등 다양한 환경에서 사용되기 시작했습니다. 여러 환경에서 C언어를 사용하기 위한 필요에 따라 점차 새로운 C언어 컴파일러도 만들어졌는데, 당시 개발자들은 기본적으로 TCPL의 내용을 기반으로 컴파일러를 개발했습니다. 하지만 안타깝게도, TCPL은 C언어의 모든 기능에 대해 명확한 문법적, 의미론적인 정의를 내리지는 않았습니다. 또한, TCPL이 발간된 이후로도 C언어는 일부 기능들이 추가되거나 제거되는 등 개선이 있었습니다. 이런 상황에서 TCPL에 의존한 컴파일러 개발자들은 일부 모호한 내용에 대해 그들의 재량으로 (주로 그들이 사용하는 플랫폼에 유리한 방향으로) 컴파일러를 구현했습니다. 그러다보니 똑같은 C언어 소스 코드를 A환경에서 a컴파일러로 컴파일한 결과와 B환경에서 b컴파일러로 컴파일한 결과가 달라지는 결과를 초래했습니다. (똑같은 웹 페이지인데 IE 브라우저로 접속했을 때와 크롬 브라우저로 접속했을 때 모습이 미묘하게 다른 모습을 볼 수 있는데, 그와 유사한 맥락으로 이해하시면 됩니다.) 이러한 상황을 해결하기 위하여 ANSI(American National Standards Institute)에서 C언어의 표준을 제정합니다.</p>
<p>ANSI는 논의를 시작한 후로 여러 개선을 통해 1989년 첫 번째 표준안 ANSI X3.159-1989 &quot;Programming Language C&quot;를 완성했고, 이는 1990년 ISO(International Organization for Standardization)로부터 승인받아 ISO/IEC 9899:1990라는 이름으로 정식 표준안이 되었습니다. 이 표준안은 보통 년도를 따서 C89 라고 불립니다. 이후 컴파일러들은 이 표준안을 기반으로 개발 및 수정되었으며, C언어 개발자들은 이 표준안에 맞춰서 소스 코드를 작성하면 표준안을 지켜 만든 컴파일러 아래에서는 모두 같은 결과를 보장받을 수 있게 되었습니다.</p>
<p>첫 번째 표준안이 제정된 후로 C언어의 기능은 한동안 크게 변화하지 않았습니다. 비록 1995년에 새로운 C 표준안(ISO/IEC 9899/AMD 1:1995)이 출간되긴 하였지만, 국제 언어와 문자 집합에 대한 지원 추가가 주된 내용이었습니다. 그러다 1990년 후반에 눈에 띄는 기능 변화가 생긴 새로운 표준안 ISO/IEC 9899:1999가 제정되었습니다. 이 표준은 C99라고 불리며, IEEE 754 부동 소수점 지원, 인라인 함수, 한 줄 주석 등의 내용이 포함되었습니다. 이 중 많은 부분이 C언어로부터 파생된 언어인 C++에서 생긴 기능을 도입한 것입니다.</p>
<p>참고로 C++언어는 비야네 스트로스트룹이 C언어에다가 Class라는 기능을 추가하여 Simula언어와 같은 객체 지향 프로그래밍을 가능하게 만든 언어입니다. &quot;C with Classes&quot;라는 의미로 시작하여 처음에 C++언어는 C언어의 Superset으로 동작하였습니다. 쉽게 말해서, 이 때는 C언어로 작성한 코드를 C 컴파일러가 아니라 C++ 컴파일러로 컴파일해도 원하는 프로그램을 만들 수 있었습니다. 하지만 시간이 지나면서 C++는 굉장히 빠른 속도로 발전하였고, C99 등 새로운 표준이 제정되면서 C++은 C의 완벽한 Superset이 아니게 되었습니다. 거기에 더해 현대 C++는 Modern이라고 불리는 다양한 기능을 장착하여 객체 지향을 넘어 다양한 메타 프로그래밍을 구현하는 언어가 되었습니다.</p>
<p>다시 C언어로 돌아와서, C99의 제정 이후 대부분의 컴파일러들은 해당 표준에 맞춰 컴파일러를 업데이트 했습니다. 그런데 마이크로소프트사의 Visual C++는 기존에 C++언어가 C언어의 Superset이었기 때문에 C++ 언어에 맞춰서 컴파일러를 개발했고, C++에 새로운 기능이 생기면 그에 맞춰서 컴파일러를 업데이트 했습니다. 그런데 위에 언급했던 것과 같이 C99부터는 C++가 더이상 Superset이 아니게 되었고, VC++은 이미 C++에 맞춰 발전을 해왔기 때문에 새로운 C 표준에 맞춰 변화하기가 어렵게 되었습니다. 그 외에도, VC++은 ANSI C 표준에서 정의하지 않은 내용들을 여럿 구현하여 더 이상 표준 C언어를 지원하는 컴파일러라고 부르기 어렵게 되었습니다.</p>
<p>이후로 다시 C언어는 큰 변화 없는 평온한 나날을 보내다가, 다시 몇 가지 기능들이 추가 및 제거된 C11 표준이 제정됩니다. 재밌는 점은 부록(Annex K)에 기존 Visual C++에서 확장 기능으로 제공하던 메모리 경계 검사 함수(Bound-checking interfaces)들이 선택적 구현 사항으로 추가되었습니다. (주로 scanf_s와 같이 접미사로 _s가 붙은 함수들입니다. 선택적 구현이기에 대부분 컴파일러가 이를 지원하지 않습니다.) 가끔 이 내용을 보고 Visual C++도 이제 다시 C언어 표준을 지원하는 컴파일러라는 논란이 생겼는데, 사실 그렇지는 않습니다. 애초에 Visual C++은 restrict 키워드와 같이 새로운 C 표준 문법을 지원하지 못하게 되어 표준 컴파일러가 아니게 된 것이며, Visual C++가 제공하는 메모리 경계 검사 함수와 표준에서 정의한 메모리 경계 검사 함수는 일대일로 대응하지 않습니다. (예를 들어, Visual C++은 C11에서 정의한 set_constraint_handler_s 함수를 제공하지 않으며 C11는 Visual C++가 제공하는 vasprintf 함수를 정의하지 않습니다.) 이러한 점들 때문에 Visual C++는 최고의 C++ 도구 중 하나지만, C언어 도구로는 적합하지 않다라는 논란이 생기고는 했습니다. 그런데 Visual Studio 2022 버전부터는 이러한 점들을 개선하여 Visual C++ 또한 표준 C 문법들을 지원하기 시작했습니다. (정확히는 2019의 특정 버전부터지만, IDE상에는 여전히 버그가 생기고는 합니다.) 결국 Visual C++은 돌고 돌아 표준 C언어를 지원하는 컴파일러가 되긴 하였으나, 그 과정이 순탄치 않았던 것도 재밌는 이야기거리 입니다.</p>
<p>C11 이후 C11에서 몇 가지 오류가 수정된 C17(C18)이 제정되었으나 큰 변화는 없었고, 최근에 제정된 C23에서 몇 가지 내용들이 수정되었습니다. K&amp;R식 함수 선언 및 정의나 2의 보수가 아닌 signed integer 표현 등이 제거되었고, 몇 가지 함수와 기능들이 deprecated 되었습니다. 또한, 이진 상수, 빈 이니셜라이저, constexpr, 속성(attributes) 등의 기능이 추가되거나 true와 false가 키워드로 등록되었습니다.</p>
<p>C언어는 이렇게 크게 K&amp;R C와 ANSI C로 나뉘며, ANSI C는 표준이 제정된 년도에 따라 C89, C99, C11, C17, C23와 같이 불립니다. 일부 사람들은 ANSI C는 C89을 나타내고 이후 표준부터는 C99, C11와 같이 표기하기도 하지만, 이 책에서는 ANSI C라고 하면 표준 전부를 가리키며 특정 버전을 나타낼 때는 C89, C99와 같이 표기하기로 하겠습니다. 현대의 C 프로그램은 대부분 C89, C99, C11을 사용하고 있습니다. 특히 현대에 C언어를 가장 잘 활용하고 성공한 프로젝트로 리눅스(Linux)가 있습니다. 리눅스는 리누즈 토발즈가 개발한 유닉스 계열(UNIX-like) 운영체제입니다. 많은 분들이 이용하는 안드로이드가 이 리눅스를 기반으로 만든 운영체제이며, 대부분의 IoT 기기들도 이 리눅스를 기반으로 만들어지고 있습니다. 뿐만 아니라 대다수의 서버 컴퓨터부터 슈퍼 컴퓨터들도 리눅스를 기반으로 동작하여, 사실 세계 운영체제 점유율 순위는 윈도우가 아닌 리눅스가 압도적인 1위를 기록하고 있습니다. 이 리눅스의 대부분은 C89을 기반으로 작성되어 있으며, 최근 리누즈 토발즈는 리눅스를 C11로 변환하겠다고 발표했습니다. C언어를 공부하려는 사람이라면 마땅히 ANSI C를 기반으로 학습해야 하며, 해당 서적 또한 ANSI C를 기반으로 작성할 예정입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c언어의-특징"><a class="header" href="#c언어의-특징">C언어의 특징</a></h1>
<p>C언어는 위와 같이 유구한 역사와 함께 오랜 기간 프로그래머들이 가장 많이 사용하는 언어로 자리잡았습니다. 비록 현대에 들어서 자바와 파이썬에게 그 인기를 많이 내어주긴 하였지만 임베디드 계열에서는 여전히 가장 많이 사용하는 언어이며 여러 대학에서도 여전히 C를 입문용 언어로 가르치고 있습니다. 이런 C언어에는 다음과 같은 주요한 특징들이 있습니다. 일부 내용은 이해가 가지 않아도 괜찮으니 가볍게 읽어주세요.</p>
<ul>
<li>로우 레벨 프로그래밍 : C언어는 로우 레벨 프로그래밍이 가능한 언어입니다. 로우 레벨 프로그래밍이 무엇을 이야기하는 것일까요? 저수준 언어라고 해서 쉬운 언어다 라고 생각하신 독자분이 계시다면, 필자는 큰 동질감을 느낄 것입니다. 적어도 필자는 C언어를 처음 공부할 때 로우 레벨 언어를 쉬운 언어라고 생각했습니다. 하지만 로우 레벨 언어란 컴퓨터가 이해하기 쉬운 언어란 뜻이고, 하이 레벨 언어는 반대로 사람이 이해가 쉬운 언어란 뜻입니다. 로우 레벨 언어는 컴퓨터가 직접 해석할 수 있는 기계어나, 기계어로 일대일 대응이 가능한 어셈블리 언어가 있습니다. 하이 레벨 언어는 위에 말한 자바, 파이썬과 C언어가 있지요. '아니, C언어가 로우 레벨 프로그래밍이 가능한 언어라면서 왜 하이 레벨 언어라고 하는거지? 필자가 미친게 틀림없군.' 이라는 생각이 드셨다면 정상입니다. 컴퓨터는 C언어를 기계어처럼 직접 해석할 수 없습니다. 또한 어셈블리처럼 기계어와 C언어가 일대일로 대응하지도 않죠. C언어는 사람이 작성하기 쉽게 만들어진 언어이기에 하이 레벨 언어가 맞습니다. 그런데 C언어는 정말 특이하게도 컴퓨터의 메모리 등 하드웨어를 직접 조작할 수 있는 방법을 제공합니다. 심지어 인라인 어셈블리라는 기능으로 C언어 코드에 어셈블리 코드를 포함시킬 수도 있죠. 이러한 특징 때문에 C언어는 시스템 프로그래밍에 잘 어울리며, 로우 레벨 프로그래밍이 가능한 언어라고도 합니다.</li>
<li>소형 언어 : C언어는 사실 언어 자체적인 기능이 굉장히 작은 언어입니다. 어떤 사람은 Small Language라고 표현하고, 어떤 사람은 Compact Language라고 표현합니다. 사실 C언어는 대부분의 기능을 라이브러리라는 것에 의존하며, 언어 자체적으로는 최소한의 기능만을 유지하려고 합니다. C11 표준 문서의 Language 챕터는 150페이지도 채 되지 않습니다. K&amp;R 책에서 설명하는 언어 기능 측면은 50페이지도 되지 않죠. 반대로 이러한 특징 때문에 모호하거나 이해하기 어려워진 기능이 많습니다. 따라서 해당 서적에서는 이러한 내용들을 최대한 이해하기 쉽도록 풀어 쓸 예정입니다.</li>
<li>컴파일 언어 : C언어는 컴파일이라는 과정을 통해서 실행할 수 있는 기계어 집합인 프로그램을 만들어내는 언어입니다. 엄밀히 말해서 프로그램을 만들어내는 과정은 조금 더 복잡하지만 해당 내용은 추후에 설명하겠습니다. 아무튼, C언어로 짜여진 소스 코드는 컴퓨터에서 실행되기 전에 미리 기계어 집합으로 변환이 됩니다. (여기서 소스 코드란, 저희가 해당 언어의 문법에 맞춰서 작성한 텍스트 파일을 의미합니다.) 이렇게 변환된 프로그램을 실행하면 기계어 집합을 바로 컴퓨터가 읽어들일 수 있기 때문에 실행 속도가 굉장히 빠릅니다. 이와 반대되는 개념으로 인터프리트 언어가 있습니다. 인터프리트 언어로 작성한 소스 코드는 미리 기계어로 변환되지 않고, 실행 도중에 인터프리터라는 프로그램을 통해 소스 코드를 즉석에서 해석하여 실행합니다. 인터프리트 언어는 실행할 때 변환(interpret)과정을 거치기 때문에 일반적으로 컴파일 언어에 비하여 실행 속도가 느립니다.</li>
<li>고성능 언어 : 일반적으로 C언어로 작성한 프로그램은 실행 속도가 굉장히 빠르고 효율적입니다. 같은 일을 하는 프로그램을 C언어로 작성했을 때와 파이썬 등 다른 언어로 작성했을 때 실행 속도가 백배 가량 차이가 나기도 합니다. 메모리 사용 또한 타 언어에 비해 효율적으로 할 수 있어서 프로그램의 메모리 사용량이 적습니다. 즉, C언어로 프로그램을 잘 작성해냈다면 일반적으로 다른 언어로 작성한 프로그램보다 고성능 고효율의 프로그램이 완성됩니다.</li>
<li>역설적 이식성 : 어떤 언어가 이식성이 좋다는 이야기는 쉽게 말해서 A환경에서 작성한 소스 코드를 다른 B환경에서 그대로 사용할 수 있다는 의미입니다. C언어는 이식성이 좋으면서 좋지 않습니다. 이번에는 또 무슨 해괴한 소리를 하는건가 싶겠지만, 정말로 그렇습니다. 자바나 파이썬으로 작성한 소스 코드는 대부분의 환경에서 그대로 사용할 수 있어서 이식성이 매우 뛰어납니다. 그런데, C언어로 작성한 소스 코드는 환경이 조금 달라지면 컴파일을 할 수 없거나, 컴파일에 성공하더라도 프로그램이 예상과는 다르게 동작하고는 합니다. 예를 들어 윈도우에서 C언어로 잘 만들어진 통신 프로그램이 리눅스에서는 컴파일조차 되지 않습니다. 또한, 데스크탑 PC에 설치한 리눅스와 IoT 기기에 설치한 리눅스에서 같은 C언어로 작성한 프로그램의 동작이 달라질 수 있습니다. 그러면 이식성이 나쁜 것이 아니냐구요? 또 그렇지만은 않습니다. 위와 같이 이식이 되지 않는 이유는 C언어로 프로그램을 개발하다 보면 특정 운영체제가 제공하는 기능들을 사용하거나 C언어 표준에서 벗어난 확장 기능을 사용하는 경우들이 생기기 때문입니다. 즉, 다시 말해 C언어 표준 문법만 사용하여 작성한 소스 코드는 C언어 표준을 지원하는 컴파일러와 라이브러리가 준비되어 있는 환경 어디에서나 사용할 수 있다는 것입니다. 그리고 C언어는 위에서 언급한대로 컴팩트한 언어이기 때문에 이러한 컴파일러 등을 구현하고 구성하기가 비교적 쉽습니다. 이러한 이유로 C언어는 이식성이 좋으면서도 좋지 않다고 이야기를 하고는 합니다. 이는 다시 말해, 이식성이 좋은 C 프로그램을 작성하고 싶다면 표준 문법에 맞는 소스 코드를 작성해야 한다는 뜻이기도 하다는 점을 유의합시다.</li>
<li>강력한 제어 능력 : C언어는 역사에서 소개한 것과 같이 태생이 운영체제를 만들기 위한 언어이며, 시스템 프로그래밍을 하기 위하여 디자인되어 온 만큼 강력한 제어 능력을 가지고 있습니다. C언어로 작성한 프로그램이 하드웨어를 제어하기 위하여 포인터라는 개념을 통해 특정 메모리 주소에 직접 접근할 수 있습니다. (물론, 현대 OS에서는 권한 문제로 일반적인 유저 프로그램이 특정한 물리 주소에 직접 접근할 수는 없지만 이는 언어의 제한은 아닙니다.) 또한, C언어는 프로그램의 안정성을 위하여 프로그래머의 행위를 제한하는 현대 언어들과 달리 뛰어난 자유도를 자랑합니다. 프로그래머는 충분히 뛰어나기 때문에 대부분의 동작이 의도된 행위이다라는 믿음을 기반으로 합니다. 이러한 점들 덕분에 C언어는 굉장히 강력한 제어 능력을 갖게 되었지만, 이는 굉장한 양날의 검이 되었습니다. 잘 작성한다면 좋은 프로그램을 만들어낼 수도 있지만, 조금만 프로그램을 잘못 작성한다면 시스템에 중대한 문제를 만들어낼 수도 있는 언어입니다. 따라서, C언어로 상용 프로그램을 개발한다고 한다면 언어의 문법과 특징을 세세히 파악하고 심혈을 기울여 소스 코드를 작성하는 자세가 필요합니다.</li>
<li>UNIX 환경 친화 : 마찬가지로 역사에서 소개한 것과 같이 C언어는 UNIX라는 운영체제를 만들기 위해 탄생한 언어입니다. 그러다 보니 자연스레 UNIX 환경에 친화되어 발전했고, UNIX 시스템과 비슷한 환경에서 사용하기가 좋습니다. (참고로 역사에서도 잠깐 언급했지만 UNIX와 비슷한 환경의 시스템을 UNIX-like 시스템이라고 합니다.) 대표적인 UNIX 혹은 UNIX-like 시스템으로는 Linux, macOS, BSD가 있습니다. 해당 서적에서는 이 중 무료이며, 점유율이 높고, 접하기 비교적 쉬운 리눅스를 기준으로 실습을 진행할 것입니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="실습-환경-구축"><a class="header" href="#실습-환경-구축">실습 환경 구축</a></h1>
<p>해당 서적에서는 리눅스 운영체제 중에서 데스크탑 용도로 인기가 많은 우분투 배포판을 사용할 것입니다. 리눅스에는 우분투 외에도 레드햇, 젠투, 아치 등 많은 종류의 배포판이 존재하는데 원한다면 다른 배포판을 사용하셔도 좋습니다. 하지만 해당 서적을 보시는 대다수의 독자분들이 리눅스를 처음 사용할 것이라고 가정하여, 설치와 사용이 상대적으로 쉬운 우분투 데스크탑을 기준으로 내용을 진행하겠습니다.</p>
<h2 id="wsl로-우분투-사용하기"><a class="header" href="#wsl로-우분투-사용하기">WSL로 우분투 사용하기</a></h2>
<p>우분투를 데스크탑에 바로 설치하여도 좋지만, 윈도우를 제거하고 우분투를 사용하면 PC 게임을 포함한 대다수의 윈도우용 프로그램을 쓸 수 없거나 사용하기 힘든 상황이 발생합니다. 그렇다고 무작성 새 PC를 하나 더 구매하여 설치하는 것도 현실적으로 쉽지 않습니다. 물론 프로그래밍 공부를 핑계로 부모님께 새로운 컴퓨터 구매를 부탁드리려는 원대한 계획을 가지고 계시다면 그것도 상관 없습니다. 하지만 계획이 언제나 성공하지는 않기 때문에 우리는 대안을 마련해야 합니다. 그리고 여기서는 WSL이 훌륭한 대안책이 되어줄 것입니다. WSL은 Windows Subsystem for Linux의 약자로, 윈도우에 경량화된 리눅스를 내장시켜 리눅스에서 사용하는 실행 파일을 실행할 수 있도록 해주는 서브 시스템이라고 생각하시면 됩니다. 만약 WSL이 싫고 리눅스를 직접 사용하고 싶다면 Vmware Player나 VirtualBox와 같은 가상 머신에 우분투를 설치해도 좋지만, 입문의 편의를 위해 WSL에 Visual Studio Code를 연동하여 사용하겠습니다.</p>
<h3 id="wsl2-설치"><a class="header" href="#wsl2-설치">WSL2 설치</a></h3>
<p>우선 다음과 같이 Windows Powershell을 검색하고 우측 마우스를 클릭하여 관리자 권한으로 실행합니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/1.png?raw=true" alt="Powershell" /></p>
<p>실행된 파워쉘에서 <code>wsl --install</code> 이라는 명령어를 입력하여 WSL 설치를 수행합니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/2.png?raw=true" alt="WSL" /></p>
<p>WSL 설치가 완료되었다면 위 그림과 같은 문구가 나옵니다. 설치 완료 이 후 안내와 재부팅하여 같이 시스템을 다시 시작합니다.
재부팅 이 후 다음과 같은 화면들이 나오면 정상적으로 시스템에 우분투가 설치되고 있는 것입니다. 시스템에 따라 설치가 완료되는 시간은 다르지만, 대략 20분정도 기다린다고 생각해주시면 됩니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/3.png?raw=true" alt="ubuntu_install" />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/4.png?raw=true" alt="ubuntu_setup" /></p>
<p>설치가 완료되었으면 시스템에서 사용할 유저 이름과 패스워드를 입력해야 합니다. 영문자와 숫자를 조합하여 본인이 원하는 이름과 패스워드를 입력하시면 됩니다. 참고로 패스워드는 확인을 위하여 두 번 입력해야 하며, 보안 문제상 입력하더라도 화면에 보이지 않습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/5.png?raw=true" alt="username" /></p>
<p>유저 설정이 끝나면 파워쉘과 유사하게 명령어를 입력할 수 있게 됩니다. <code>whoami</code> 라는 명령어를 입력했을 때 본인이 설정한 유저 이름이 나온다면 정상적으로 설정이 완료된 것입니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/6.png?raw=true" alt="whoami" /></p>
<p>축하드립니다, 여러분들은 우분투에 성공적으로 입문하셨습니다. 참고로 앞으로 WSL을 사용하고 싶으면 윈도우 검색 창에 wsl라고 입력하여 나오는 펭귄 아이콘의 실행 파일을 실행하시면 됩니다. (다시 실행하는 경우 현재 디렉토리가 다르게 설정될 수 있으니 아래에 있는 <code>cd</code> 명령을 통해 홈 디렉토리로 이동을 하면 됩니다.) 그리고 리눅스에 입문했다고 이야기 하지 않는 이유는, 본인도 모르는 사이 리눅스를 사용해봤을 확률이 높기 때문입니다. 만약 안드로이드 스마트폰을 사용하셨다면 안드로이드 운영체제 또한 리눅스를 기반으로 만들어진 운영체제이기 때문에 이미 리눅스는 충분히 사용하셨습니다. 
리눅스를 포함한 대부분의 UNIX-like 시스템에서는 윈도우와 같이 그래픽 화면에 아이콘 등이 상호작용하며 사용하는 GUI(Graphical User Interface)도 지원하지만 지금 사용한 방법과 같이 검은 창에 명령어를 입력하여 실행하는 CLI(Command Line Interface)를 애용하게 됩니다. 해당 서적이 리눅스를 가르쳐주는 서적은 아니지만, 이 후 사용의 편의를 위하여 앞으로 사용할 몇 가지 명령어들만 간단하게 설명하도록 하겠습니다.</p>
<ul>
<li><code>nano</code> : <code>nano -w hello.txt</code> 라는 명령을 입력하면 다음과 같이 새로운 텍스트 파일을 작성할 수 있습니다. nano 외에도 vim이나 emacs와 같은 편집기를 사용할 수도 있지만, 저희는 어차피 이 후에 Visual Studio Code를 연동하여 사용할 것이므로 테스트하기 쉬운 nano 편집기를 임시로 사용해보겠습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/7.png?raw=true" alt="nano" /><br />
nano 명령을 입력하여 새로운 창이 뜨면, 원하는 내용을 입력해줍니다. 입력이 완료되었으면 <strong>Ctrl + X</strong> 키를 눌러서 입력을 종료할 수 있습니다. 하단 바가 아래 그림과 같이 변경되면 입력한 내용을 저장할지, 버릴지 혹은 종료를 취소할지 선택할 수 있습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/8.png?raw=true" alt="nano2" /><br />
<strong>Y</strong> 키를 눌러서 입력한 내용을 저장하려고 하면 하단 바가 다시 변경되어 저장할 파일의 이름을 지정해줄 수 있습니다. 여기에서 파일 이름을 다시 지정해줘도 괜찮지만, 처음 nano 명령을 실행할 때 작성할 파일의 이름을 지정해줬으므로 엔터를 치고 넘어가시면 됩니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/9.png?raw=true" alt="nano3" /><br />
그러면 다음 그림과 같이 기존의 입력 쉘 화면으로 돌아올 것입니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/10.png?raw=true" alt="nano4" /></li>
<li><code>ls</code> : 현재 디렉토리(폴더)에 있는 파일 리스트를 확인하는 명령어 입니다. <code>ls</code>만 단독으로 사용하면 간단한 내용만 보여주며, <code>ls -a</code>라고 a 옵션을 주면 파일 이름이 .(dot)로 시작하는 숨김 파일도 볼 수 있으며, <code>ls -l</code>라고 l 옵션을 주면 상세한 내용을 볼 수 있습니다. 옵션은 <code>ls -al</code>과 같이 조합하여 사용할 수도 있습니다. 해당 명령어를 사용하면 저희가 방금 작성한 <code>hello.txt</code> 파일이 저장되어 있는 것을 볼 수 있습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/11.png?raw=true" alt="ls" /></li>
<li><code>cat</code> : 파일을 이어 붙여서 출력해주는 명령어입니다. 저희가 방금 생성한 파일에 대해 <code>cat hello.txt</code>와 같이 사용하면 파일에 작성한 내용을 읽어서 출력해줍니다. 참고로 concatenate라는 단어에서 파생된 명령어로, <code>cat hello.txt hello2.txt</code> 명령과 같이 사용하면 여러 파일을 이어서 출력할 수 있습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/12.png?raw=true" alt="cat" /></li>
<li><code>mkdir</code> : 새로운 디렉토리(폴더)를 생성하는 명령어 입니다. <code>mkdir src</code>와 같이 사용하면 현재 디렉토리에 src 라는 이름의 하위 디렉토리를 생성할 수 있습니다. 생성 이 후 <code>ls</code> 명령으로 확인하면 일반 파일과 달리 디렉토리는 다른 색상으로 표시되는 것을 볼 수 있습니다.
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/13.png?raw=true" alt="mkdir" /></li>
<li><code>cd</code> : 현재 자신이 위치하는 디렉토리를 변경하는 명령어 입니다. <code>cd src</code> 명령으로 방금 전에 생성한 디렉토리로 이동할 수 있습니다. <code>cd ..</code>와 같이 <code>..</code>을 사용하면 한 단계 상위 디렉토리로 이동하며, <code>cd /</code>와 같이 <code>/</code>로 이동하면 시스템의 최상위(루트) 디렉토리로 이동합니다. <code>cd /home/pr0gr4m/src</code>와 같이 최상위 경로부터 시작한 특정 위치의 디렉토리로 한번에 이동할 수도 있습니다. 뿐만 아니라, <code>cd</code>만 단독으로 사용하거나 <code>cd ~</code>와 같이 <code>~</code>를 사용하면 <code>/home/&lt;유저이름&gt;</code>에 해당하는 홈 디렉토리로 바로 이동할 수도 있습니다.
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/14.png?raw=true" alt="cd" /></li>
<li><code>pwd</code> : 현재 자신이 위치한 디렉토리의 경로가 어디인지 출력해주는 명령어 입니다.
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/15.png?raw=true" alt="pwd" /></li>
<li><code>&lt;Ctrl + L&gt;</code> : 명령어는 아니지만 터미널 화면을 정리해주는 단축키 입니다. 위 그림들에서 가끔 이 전 명령어가 보이지 않고 처음부터 새로운 명령어를 사용하는 것처럼 보이는 이유가 해당 단축키를 이용하여 화면을 정리하였기 때문입니다.</li>
</ul>
<p>이 외에도 리눅스에서 자주 사용하는 명령어는 굉장히 많지만 당장은 이 정도만 알고 있더라도 이 후 내용 진행에 무리는 없을 것 같습니다. 해당 명령어들을 지금 굳이 외울 필요는 없고, 필요할 때마다 찾아보고 사용하시다 보면 자연스레 외워지게 됩니다. 그리고 이 외에 내용 진행에 필요한 명령어들은 그때그때에 맞춰서 다시 설명하도록 하겠습니다.</p>
<h3 id="visual-studio-code-설치-및-연동"><a class="header" href="#visual-studio-code-설치-및-연동">Visual Studio Code 설치 및 연동</a></h3>
<p>위에서 익힌 <code>nano</code> 혹은 여타 전통의 편집기인 <code>vim</code>과 같은 에디터를 통해 소스 코드를 작성하여 실습을 진행할 수도 있습니다. 유닉스/리눅스의 장인이 되고 싶다면 이러한 수련법도 나쁘지 않지만, C언어 공부도 쉽지 않은데 실습 환경마저 불친절하면 불타올랐던 학습 열정이 사그라들 수도 있습니다. 따라서 저희는 마이크로소프트에서 제공하는 무료 소스 코드 편집기인 Visual Studio Code(이 후 vsc라고 통칭합니다)를 연동하여 상대적으로 쉽고 편한 환경에서 실습을 진행할 것입니다.
우선 vsc의 설치 링크 <a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a>로 이동합니다. 아래와 같은 화면이 나오면 본인이 현재 사용하고 있는 운영체제(윈도우를 사용중이라면 WSL에 연동한다고 해서 리눅스를 선택하면 안되고, 윈도우를 선택해야 합니다)를 클릭하여 설치 파일을 다운로드 받고 실행합니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/16.png?raw=true" alt="vsc_down" /><br />
설치 과정은 여타 프로그램 설치와 다르지 않게 다음과 설치 버튼을 눌러서 설치해주시면 됩니다. 설치가 완료되고 vsc 프로그램을 실행하면 다음과 같은 화면을 보실 수 있습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/17.png?raw=true" alt="vsc_exec" /><br />
설치가 완료되었다면 vsc는 종료하고, wsl로 돌아오도록 하겠습니다. wsl에서 이 전에 생성했던 src(소스) 디렉토리로 이동한 후, <code>code .</code> 명령을 실행하면 간단하게 wsl과 vsc가 연동이 됩니다.<br />
<img src="https://docs.microsoft.com/ko-kr/windows/wsl/media/wsl-open-vs-code.gif" alt="wsl_vsc" /><br />
vsc가 연동되어 실행이 되었다면 현재 사용자를 신뢰할 것인가에 대한 물음이 나옵니다. 'Yes, I trust the authors' 버튼을 클릭해 줍니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/18.png?raw=true" alt="trust" /><br />
그러면 연동이 완료된 vsc 홈 화면을 볼 수 있습니다. 좌측에는 탐색기(explorer), 검색(search), 소스 관리(source control), 실행 및 디버그(run and debug), 확장(extensions) 탭이 있는데 자세한 기능들은 필요할 때마다 설명드리도록 하겠습니다. 그리고 우측에는 새로운 파일을 생성하거나 최근에 작업하던 파일을 열 수 있는 간단한 화면들이 보입니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/19.png?raw=true" alt="vsc_home" /><br />
우선 저희는 연동이 잘 되었는지 테스트하기 위하여 좌측 탐색기에 우측 마우스를 클릭한 후, New File을 눌러 새로운 파일을 생성해보도록 하겠습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/20.png?raw=true" alt="vsc_new" /><br />
파일 이름은 간단하게 <code>test.txt</code>라고 하였으며, 파일 내용은 test라고 작성했습니다. 원하는 내용을 작성한 후, <code>&lt;Ctrl + S&gt;</code> 단축키를 누르면 작성한 내용이 저장됩니다.
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/21.png?raw=true" alt="vsc_test" /><br />
그리고 나서 wsl 창으로 돌아오면 src 디렉토리 아래에 다음과 같이 vsc에서 작성한 test.txt 파일이 있는 것을 볼 수 있습니다.
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/22.png?raw=true" alt="vsc_test2" /><br />
참고로 test.txt 파일이 개행 문자로 끝나지 않아서 test라는 텍스트가 출력된 후 바로 옆에 다음 명령줄이 이어서 출력된 것을 볼 수 있습니다. 이는 잘못된 것이 아니고, vsc에서 생성한 파일 마지막에 엔터를 눌러 개행문자를 추가하고 저장하면 좀 더 깔끔한 결과를 볼 수 있으니 참고하시기 바랍니다.</p>
<p>아무튼 이리하여 wsl에 vsc를 연동하는 것은 성공했습니다. 하지만, vsc를 실행하기 위하여 매번 wsl을 실행하고 명령어를 입력하기 위하여 vsc와 wsl 창을 왔다갔다 움직이는 것은 여간 번거로운 일이 아닙니다. 따라서 vsc에서 wsl에 연동하는 확장 프로그램을 설치하여 앞으로는 wsl 창을 열 필요 없이 vsc에서 대부분의 작업을 끝낼 수 있도록 하겠습니다.
vsc의 좌측 Extensions 탭에서 Remote-WSL을 검색하여 WSL 연동을 위한 확장을 설치해줍니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/26.png?raw=true" alt="ext_wsl" /><br />
설치가 완료되었다면 vsc를 다시 시작했을 때 그림과 같이 좌측 하단에 Open a Remote Window라는 버튼이 생깁니다. 해당 버튼을 클릭하거나 vsc에서 <code>&lt;Ctrl + Shift + P&gt;</code> 단축키를 입력하고 New WSL Window를 검색하면 다음과 같은 화면을 볼 수 있습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/27.png?raw=true" alt="remote" /><br />
New WSL Window를 클릭하면 좌측 하단에 <strong>WSL:Ubuntu</strong> 라는 문구가 추가된 vsc 화면을 볼 수 있습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/28.png?raw=true" alt="remote_ubuntu" /><br />
여기에서 좌측 Explorer 탭을 누르면 Open Folder라는 버튼을 확인할 수 있는데, 해당 버튼을 누르고 원하는 디렉토리 경로를 지정하여 OK 버튼을 누르면 해당 디렉토리에 연동된 작업 공간을 구성할 수 있습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/29.png?raw=true" alt="remote_dir" /><br />
이 전에 만들어뒀던 src 디렉토리를 입력하여 OK 버튼을 눌러줍니다. 그러면 이 후부터는 vsc 홈 화면의 Recent 란에서 wsl에 있는 src 디렉토리를 바로 연동하여 사용할 수 있습니다.
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/30.png?raw=true" alt="remote_home" /><br />
이렇게 <strong>WSL:Ubuntu</strong> 문구가 보이는 vsc에서는 모든 작업들을 wsl에 연동하여 실행할 수 있습니다. wsl 창에서 수행하던 명령어들도 vsc에 내장되어있는 터미널을 연동하여 수행할 수 있습니다. 그러기 위하여 상단 바에서 <code>&lt;Terminal&gt; -&gt; &lt;New Terminal&gt;</code>를 클릭하거나 <code>&lt;Ctrl&gt; + &lt;Shift&gt; + &lt;`&gt;</code> 단축키를 입력하여 터미널을 열어줄 수 있습니다. 그러면 해당 터미널에서 여태까지 배웠던 모든 명령어들을 바로 실행할 수 있습니다. 따라서, 앞으로 wsl를 굳이 실행하지 않고도 vsc만 실행하여 작업을 수행할 수 있습니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/31.png?raw=true" alt="remote_ter" /></p>
<p>그러면 이제 마지막으로, vsc에 몇 가지 확장 기능들을 설치하고 C 프로그래밍을 하기 위한 도구들을 터미널에서 설치해주면 모든 작업이 마무리됩니다.</p>
<h3 id="c-프로그래밍-환경-구성"><a class="header" href="#c-프로그래밍-환경-구성">C 프로그래밍 환경 구성</a></h3>
<p>C언어로 소스 코드를 작성하고 나면 이를 컴퓨터가 이해할 수 있는 기계어로 변환(번역, translation)해줄 컴파일러가 필요합니다. 또한 소스 코드로 실행 파일을 만드는 빌드 작업을 편하게 자동화시켜 줄 빌드 툴과 프로그램에 오류가 있을 때 오류를 찾아 수정하는 디버거도 사용하는 것이 좋습니다. 이러한 컴파일러 및 빌드 툴과 디버거는 wsl에 내장되어있지 않기 때문에 터미널에서 다음과 같은 두 명령어를 통해 추가로 설치해주도록 하겠습니다.</p>
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install -y build-essential gdb
</code></pre>
<p>참고로 <code>apt</code> 는 우분투 등에서 프로그램의 설치 및 삭제를 관리하는 명령어이고, <code>sudo</code>는 명령어를 슈퍼 유저 권한(우선은 관리자 권한과 비슷하다고 생각하시면 됩니다)으로 실행시켜주는 명령어 입니다. <code>update</code>는 설치 가능한 프로그램 패키지 리스트를 최신화하는 명령이며, <code>install</code>는 실제 설치를 위한 명령어 입니다. 그리고  <code>build-essential</code>은 리눅스에서 자주 사용하는 <code>gcc</code> 컴파일러와 <code>make</code> 빌드툴 등의 통합 패키지이며, <code>gdb</code>는 디버거입니다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/23.png?raw=true" alt="gcc" /><br />
제 환경에는 이미 설치가 되어있었기 때문에 위와 같은 문구가 나오지만, 실제로는 좀 더 긴 설치 문구들이 나올 것입니다. 설치가 완료된 후 다음과 같이 세 명령어를 입력하면 각 프로그램들의 버전 정보를 볼 수 있습니다.</p>
<pre><code class="language-bash">$ gcc --version
$ make --version
$ gdb --version
</code></pre>
<p><img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/24.png?raw=true" alt="version" /></p>
<p>그러면 이제 마지막으로, vsc에 몇 가지 확장 기능들을 설치하고 wsl 터미널에 직접 연결할 수 있도록 연동해주면 모든 작업이 마무리됩니다. vsc의 좌측 Extensions 탭에서 C를 검색하여 나온 결과 중 다음과 같이 C/C++ Extension Pack을 설치하여 줍시다.<br />
<img src="https://github.com/pr0gr4m/Hello-C-World/blob/main/img/C%EC%96%B8%EC%96%B4%20%EC%86%8C%EA%B0%9C/25.png?raw=true" alt="ext" /></p>
<p>설치가 완료되었다면 모든 준비가 완료되었습니다. 이제 본격적으로 C언어를 배우고 C 프로그램을 작성해보도록 하겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>1장의 실습 환경 구축에 이어서, 생애 첫 C언어 프로그램을 작성해보도록 하겠습니다. 이번 챕터의 내용은 이해가 가지 않더라도 무작정 따라해주시면 되겠습니다. 우선 <code>hello.txt</code>나 <code>test.txt</code> 파일을 생성한 것과 같이, <code>hello.c</code>라는 파일을 생성하여 다음과 같이 입력해줍시다. 참고로 C언어로 작성한 소스 코드의 확장자 명은 <code>.c</code> 입니다.</p>
<pre><code class="language-c">// hello.c
#include &lt;stdio.h&gt;

int main(void)
{
    printf(&quot;Hello, World!\n&quot;);
    return 0;
}
</code></pre>
<p>위 내용을 포함하여 해당 서적에 있는 모든 소스 코드는 꼭 직접 손으로 쳐서 작성해주도록 합시다. 참고로 키보드에 <code>\</code>(역슬래쉬) 문자가 없고 <code>₩</code>(원) 문자가 있다면 원 문자를 입력해주시면 됩니다. 그렇게 해당 내용을 오탈자 없이 잘 작성했다면 wsl에 연동되어있는 vsc 터미널을 열어서 <code>ls</code> 명령어로 현재 디렉토리에 <code>hello.c</code> 파일이 잘 있는지 확인한 후, <code>make hello</code> 라는 명령어를 입력해 줍시다. 그러면 여러분이 작성한 소스 코드가 빌드되어 <code>hello</code>라는 실행 파일이 생성되는 것을 볼 수 있습니다.</p>
<pre><code class="language-bash">pr0gr4m@DESKTOP-IRB9MN5:~/src$ ls
hello.c  test.txt
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make hello
cc     hello.c   -o hello
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ls
hello  hello.c  test.txt
pr0gr4m@DESKTOP-IRB9MN5:~/src$ 
</code></pre>
<p>축하드립니다. 성공적으로 첫 C 소스 코드를 작성하여 프로그램을 만들었습니다. 이제 터미널에서 <code>./hello</code> 라고 입력하여 저희가 만들어낸 첫 프로그램을 실행해주도록 합시다. 이 전까지 입력했던 명령어들과 달리 hello 앞에 <code>./</code>가 붙는 것에 유의하시기 바랍니다. 이는 현재 디렉토리에 있는 <code>hello</code>라는 실행 파일을 실행하겠다는 의미입니다.</p>
<pre><code class="language-bash">pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./hello 
Hello, World!
</code></pre>
<p>'Hello, World!' 라는 문자열을 출력하는 것을 볼 수 있습니다.</p>
<p>간혹가다가 <code>make hello</code> 명령어를 입력했을 때 위처럼 <code>cc     hello.c   -o hello</code>가 아닌 다음과 같은 오류가 발생하는 경우가 있습니다.</p>
<pre><code class="language-bash"># 오류 1번
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make hello
cc     hello.c   -o hello
hello.c:1:10: fatal error: studio.h: No such file or directory
    1 | #include &lt;studio.h&gt;
      |          ^~~~~~~~~~
compilation terminated.
make: *** [&lt;builtin&gt;: hello] Error 1

# 오류 2번
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make hello
cc     hello.c   -o hello
hello.c: In function ‘main’:
hello.c:5:29: error: expected ‘;’ before ‘return’
    5 |     printf(&quot;Hello, World!\n&quot;)
      |                             ^
      |                             ;
    6 |     return 0
      |     ~~~~~~                   
make: *** [&lt;builtin&gt;: hello] Error 1
</code></pre>
<p>오류 1번은 <code>&lt;stdio.h&gt;</code> 대신에 visual studio에 심취한 나머지 <code>&lt;studio.h&gt;</code> 라는 오탈자를 입력한 경우이고, 오류 2번은 <code>printf(&quot;Hello, World!\n&quot;)</code>나 <code>return 0</code> 다음에 세미콜론 문자 <code>;</code>를 누락한 경우입니다. 그 외에도 정상적인 결과가 나오지 않는 경우는 99.99%의 확률로 오탈자를 입력한 것이니 내용을 유심히 확인하시면 원하는 결과를 볼 수 있을 겁니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
